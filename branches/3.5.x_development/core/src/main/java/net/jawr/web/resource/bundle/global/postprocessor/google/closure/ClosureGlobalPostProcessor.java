/**
 * Copyright 2011 Ibrahim Chaehoi
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package net.jawr.web.resource.bundle.global.postprocessor.google.closure;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import net.jawr.web.JawrConstant;
import net.jawr.web.config.JawrConfig;
import net.jawr.web.exception.BundlingProcessException;
import net.jawr.web.exception.ResourceNotFoundException;
import net.jawr.web.resource.bundle.IOUtils;
import net.jawr.web.resource.bundle.JoinableResourceBundle;
import net.jawr.web.resource.bundle.factory.global.postprocessor.GlobalPostProcessingContext;
import net.jawr.web.resource.bundle.factory.util.PathNormalizer;
import net.jawr.web.resource.bundle.global.processor.AbstractChainedGlobalProcessor;
import net.jawr.web.resource.bundle.handler.ResourceBundlesHandler;
import net.jawr.web.resource.bundle.variant.VariantSet;
import net.jawr.web.resource.bundle.variant.VariantUtils;
import net.jawr.web.util.FileUtils;
import net.jawr.web.util.StringUtils;

import org.apache.log4j.Logger;

import com.google.common.io.CharStreams;
import com.google.javascript.jscomp.CommandLineRunner;
import com.google.javascript.jscomp.JSSourceFile;


/**
 * This class defines the Closure global post processor.
 * This post processor will work on the bundle generated by the Jawr processing.
 * By default, this postprocessor will use the WHITESPACE_ONLY compilation level. 
 *  
 * @author Ibrahim Chaehoi
 */
public class ClosureGlobalPostProcessor extends AbstractChainedGlobalProcessor<GlobalPostProcessingContext> {

	/** The logger */
	private static final Logger LOGGER = Logger
			.getLogger(ClosureGlobalPostProcessor.class);
	
	/** The module argument for the closure command line runner */
	private static final String MODULE_ARG = "--module";

	/** The js argument for the closure command line runner */
	private static final String JS_ARG = "--js";

	/** The externs argument for the closure command line runner */
	private static final String EXTERNS_ARG = "--externs";

	/** The compilation argument for the closure command line runner */
	private static final String COMPILATION_LEVEL_ARG = "--compilation_level";

	/** The whitespace_only compilation level */
	private static final String WHITESPACE_ONLY_COMPILATION_LEVEL = "WHITESPACE_ONLY";

	/** The simple optimization compilation level */
	private static final String SIMPLE_OPTIMIZATIONS_COMPILATION_LEVEL = "SIMPLE_OPTIMIZATIONS";

	/** The advanced optimizations compilation level */
	private static final String ADVANCED_OPTIMIZATIONS_COMPILATION_LEVEL = "ADVANCED_OPTIMIZATIONS";

	/** The warning level argument for the closure command line runner */
	private static final String WARNING_LEVEL_ARG = "--warning_level";

	/** The verbose warning level for the closure compiler */
	private static final String VERBOSE_WARNING_LEVEL = "VERBOSE";

	/** The closure modules property, whose the value will be passed to the closure compiler */
	private static final String JAWR_JS_CLOSURE_MODULES = "jawr.js.closure.modules";
	
	/** The compilation level property, whose the value will be passed to the closure compiler */
	private static final String JAWR_JS_CLOSURE_COMPILATION_LEVEL = "jawr.js.closure.compilation.level";

	/** The externs property whose the value will be passed to the closure compiler */
	private static final String JAWR_JS_CLOSURE_EXTERNS = "jawr.js.closure.externs";

	/** The google closure temporary directory */
	private static final String GOOGLE_CLOSURE_TEMP_DIR = "/googleClosure/temp/";

	/** The google closure result directory */
	private static final String GOOGLE_CLOSURE_RESULT_DIR = "/googleClosure/result/";
	
	/** The JAWR root module file path */
	private static final String JAWR_ROOT_MODULE_JS = "/JAWR_ROOT_MODULE.js";
	
	/** The JAWR root module file name */
	private static final String JAWR_ROOT_MODULE_NAME = "JAWR_ROOT_MODULE";
	
	/** The source directory */
	private String srcDir;
	
	/** The destination directory */
	private String destDir;
	
	/** The temporary directory */
	private String tempDir;
	
	/**
	 * Constructor
	 */
	public ClosureGlobalPostProcessor() {
		super(JawrConstant.GLOBAL_GOOGLE_CLOSURE_POSTPROCESSOR_ID);
	}
	
	/**
	 * Constructor
	 */
	public ClosureGlobalPostProcessor(String srcDir, String tempDir, String destDir) {
		super(JawrConstant.GLOBAL_GOOGLE_CLOSURE_POSTPROCESSOR_ID);
		this.srcDir = srcDir;
		this.destDir = destDir;
		this.tempDir = tempDir;
	}

	/* (non-Javadoc)
	 * @see net.jawr.web.resource.bundle.global.processor.GlobalProcessor#processBundles(net.jawr.web.resource.bundle.global.processor.AbstractGlobalProcessingContext, java.util.List)
	 */
	public void processBundles(GlobalPostProcessingContext ctx,
			List<JoinableResourceBundle> bundles) {
		
		String workingDir = ctx.getRsReaderHandler().getWorkingDirectory(); 
		
		if(srcDir == null || destDir == null || tempDir == null){
			srcDir = ctx.getBundleHandler().getBundleTextDirPath();
			destDir = workingDir + GOOGLE_CLOSURE_RESULT_DIR;
			tempDir = workingDir + GOOGLE_CLOSURE_TEMP_DIR;
		}
		
		// Copy the bundle files in a temp directory
		try {
			FileUtils.copyDirectory(new File(srcDir), new File(
					tempDir));

			//Properties =
			Map<String, String> resultBundleMapping = new HashMap<String, String>();
			JawrClosureCommandLineRunner cmdRunner = new JawrClosureCommandLineRunner(
					ctx, bundles, resultBundleMapping);
			cmdRunner.doRun();
			FileUtils.copyDirectory(new File(destDir), new File(
					srcDir));

		} catch (Exception e) { // Check exception because FlagUsageException is
								// not public
			throw new BundlingProcessException(e);
		}

	}

	/**
	 * Returns the closure compiler arguments
	 * @param ctx the global processing context
	 * @param tmpBundles the bundles
	 * @param resultBundlePathMapping the object which defines the mapping between the bundle name and the bundle path 
	 * @return
	 */
	private String[] getClosureCompilerArgs(GlobalPostProcessingContext ctx,
			List<JoinableResourceBundle> tmpBundles, Map<String, String> resultBundlePathMapping) {

		List<String> args = new ArrayList<String>();
		JawrConfig config = ctx.getJawrConfig();
		List<JoinableResourceBundle> bundles = new ArrayList<JoinableResourceBundle>(
				tmpBundles);
		String externs = config.getProperty(JAWR_JS_CLOSURE_EXTERNS);

		// TODO Handle All closure parameter
		args.add(WARNING_LEVEL_ARG);
		args.add(VERBOSE_WARNING_LEVEL);

		String compilationLevel = config.getProperty(JAWR_JS_CLOSURE_COMPILATION_LEVEL);
		if(!ADVANCED_OPTIMIZATIONS_COMPILATION_LEVEL.equalsIgnoreCase(compilationLevel)
				&& !WHITESPACE_ONLY_COMPILATION_LEVEL.equalsIgnoreCase(compilationLevel)
				&& !SIMPLE_OPTIMIZATIONS_COMPILATION_LEVEL.equalsIgnoreCase(compilationLevel)){
		
			if(StringUtils.isNotEmpty(compilationLevel)){
				LOGGER.debug("Closure compilation level defined in config '"+compilationLevel+"' is not part of the available " +
					"ones [WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS");
			}
			compilationLevel = WHITESPACE_ONLY_COMPILATION_LEVEL;
		}
		
		LOGGER.debug("Closure compilation level used : "+compilationLevel);
		
		args.add(COMPILATION_LEVEL_ARG);
		args.add(compilationLevel);
		
		// --externs
		if (StringUtils.isNotEmpty(externs)) {
			args.add(EXTERNS_ARG);
			args.add(externs);
		}
		
		// handle modules
		Map<String, JoinableResourceBundle> bundleMap = new HashMap<String, JoinableResourceBundle>();
		for (JoinableResourceBundle bundle : bundles) {
			bundleMap.put(bundle.getName(), bundle);
		}

		String modules = config.getProperty(JAWR_JS_CLOSURE_MODULES);
		List<String> depModulesArgs = new ArrayList<String>();
		
		List<JoinableResourceBundle> globalBundles = getRsBundlesHandler(ctx).getGlobalBundles();
		List<String> globalBundleDependencies = new ArrayList<String>();
		// TODO Handle globalBundle deep dependencies
		for (JoinableResourceBundle globalBundle : globalBundles) {
			globalBundleDependencies.add(globalBundle.getName());
		}
		
		// Define Jawr root module
		// The JAWR_ROOT_MODULE is a fake module to give a root module to the dependency graph
		// This is it's only purpose. It is the root dependency for any module
		// This is used because Google Closure use a unique module as root for dependency management
		// in advance mode
		args.add(JS_ARG);
		args.add(JAWR_ROOT_MODULE_JS);

		args.add(MODULE_ARG);
		args.add(JAWR_ROOT_MODULE_NAME+":1:");
		resultBundlePathMapping.put(JAWR_ROOT_MODULE_NAME, JAWR_ROOT_MODULE_JS);
		
		if(StringUtils.isNotEmpty(modules)){
			String[] moduleSpecs = modules.split(";");
			for (String moduleSpec : moduleSpecs) {
				int moduleNameSeparatorIdx = moduleSpec.indexOf(":");
				if (moduleNameSeparatorIdx < 0) {
					throw new BundlingProcessException(
							"The property 'jawr.js.closure.modules' is not properly defined. Please check your configuration.");
				}
	
				// Check module name
				String bundleName = moduleSpec.substring(0, moduleNameSeparatorIdx);
				checkBundleName(bundleName, bundleMap);
				JoinableResourceBundle bundle = bundleMap.get(bundleName);
				List<String> dependencies = Arrays.asList(moduleSpec.substring(
						moduleNameSeparatorIdx + 1).split(","));
				dependencies.addAll(0, globalBundleDependencies);
				generateBundleModuleArgs(depModulesArgs, bundleMap, resultBundlePathMapping, bundle,
						dependencies);
	
				// Remove the bundle from the list of bundle to treat
				bundles.remove(bundle);
			}
		}
		
		// handle the other bundles
		for (JoinableResourceBundle bundle : bundles) {
			generateBundleModuleArgs(args, bundleMap, resultBundlePathMapping, bundle, globalBundleDependencies);
		}

		// Add dependency modules args after to conform to dependency definition
		// of closure args
		args.addAll(depModulesArgs);

		if(LOGGER.isDebugEnabled()){
			StringBuilder strArg = new StringBuilder();
			for (String arg : args) {
				strArg.append(arg+" ");
			}
			
			LOGGER.debug("Closure Compiller Args : "+strArg.toString());
		}
		return args.toArray(new String[] {});
	}

	/**
	 * Generates the bundle module arguments for the closure compiler
	 * @param args the current list of arguments
	 * @param bundleMap the bundle map
	 * @param resultBundleMapping the result bundle mapping
	 * @param bundle the current bundle
	 * @param dependencies the dependencies
	 */
	private void generateBundleModuleArgs(List<String> args,
			Map<String, JoinableResourceBundle> bundleMap, Map<String, String> resultBundleMapping,
			JoinableResourceBundle bundle, List<String> dependencies) {
		
		Set<String> bundleDependencies = getClosureModuleDependencies(bundle,
				dependencies);
		
		// Generate a module for each bundle variant
		Map<String, VariantSet> bundleVariants = bundle.getVariants();
		List<Map<String, String>> variants = VariantUtils
				.getAllVariants(bundleVariants);
		// TODO should it be defined directly in getAllVariants or
		// bundle.getVariants ?
		
		// Add default variant
		if(variants.isEmpty()){
			variants.add(null);
		}
		for (Iterator<Map<String, String>> iterator = variants.iterator(); iterator
				.hasNext();) {
			Map<String, String> variant = iterator.next();

			String jsFile = VariantUtils.getVariantBundleName(bundle.getId(),
					variant);
			String moduleName = VariantUtils.getVariantBundleName(
					bundle.getName(), variant);
			
			resultBundleMapping.put(moduleName, jsFile);
			
			args.add(JS_ARG);
			args.add(jsFile);

			args.add(MODULE_ARG);
			StringBuilder moduleArg = new StringBuilder();
			moduleArg.append(moduleName + ":1:");
			for (String dep : bundleDependencies) {
				
				// Check module dependencies
				checkBundleName(dep, bundleMap);

				JoinableResourceBundle dependencyBundle = bundleMap.get(dep);
				// Generate a module for each bundle variant
				List<String> depVariantKeys = VariantUtils
						.getAllVariantKeysFromFixedVariants(
								dependencyBundle.getVariants(), variant);

				// TODO check if it should not be moved to variantUtils or
				// bundle
				if(depVariantKeys.isEmpty()){
					depVariantKeys.add(null);
				}
				for (Iterator<String> itDepVariantKey = depVariantKeys
						.iterator(); itDepVariantKey.hasNext();) {
					String depVariantKey = itDepVariantKey.next();
					String depBundleName = VariantUtils.getVariantBundleName(
							dep, depVariantKey);
					moduleArg.append(depBundleName);
					moduleArg.append(",");
				}
			}
			moduleArg.append(JAWR_ROOT_MODULE_NAME);
			args.add(moduleArg.toString());
		}
	}

	/**
	 * Returns the module bundle dependency from the bundle dependency and the declared dependencies 
	 * @param bundle the bundle
	 * @param dependencies the declared dependencies
	 * @return the list of the module dependency
	 */
	private Set<String> getClosureModuleDependencies(
			JoinableResourceBundle bundle, List<String> dependencies) {
		
		Set<String> bundleDependencies = new HashSet<String>();
		if(bundle.getDependencies() != null){
			for (JoinableResourceBundle depBundle : bundle.getDependencies()) {
				bundleDependencies.add(depBundle.getName());
			}
		}
		for (String depBundleName : dependencies) {
			bundleDependencies.add(depBundleName);
		}
		return bundleDependencies;
	}

	/**
	 * Checks the bundle name
	 * @param bundleName the bundle name
	 * @param bundleMap the bundle map
	 */
	private void checkBundleName(String bundleName,
			Map<String, JoinableResourceBundle> bundleMap) {
		if(!JAWR_ROOT_MODULE_NAME.equals(bundleName)){
			boolean moduleExist = bundleMap.get(bundleName) != null;
			if (!moduleExist) {
				throw new BundlingProcessException(
						"The bundle name '"
								+ bundleName
								+ "' defined in 'jawr.js.closure.modules' is not defined in the configuration. Please check your configuration.");
			}
		}
	}
	

	/**
	 * Returns the ResourcebundlesHandler
	 * @param the global processing context
	 * @return the ResourcebundlesHandler
	 */
	public ResourceBundlesHandler getRsBundlesHandler(GlobalPostProcessingContext ctx){
		return ctx.getBundleHandler();
	}
	
	/**
	 * The Closure command line runner for Jawr
	 * 
	 * @author Ibrahim Chaehoi
	 */
	private class JawrClosureCommandLineRunner extends CommandLineRunner {
		
		/**
		 * The fake prefix to be used for the bundle handler 
		 */
		private static final String FAKE_PREFIX = "/fakePrefix/";
		
		/**
		 * The global postprocessing context 
		 */
		private GlobalPostProcessingContext ctx;
		
		/**
		 * The result bundle mapping 
		 */
		private Map<String, String> resultBundleMapping;
			
		/**
		 * Constructor
		 * @param ctx the global post processing context
		 * @param bundles the bundles
		 * @param resultBundleMapping the result bundle mapping 
		 */
		public JawrClosureCommandLineRunner(GlobalPostProcessingContext ctx,
				List<JoinableResourceBundle> bundles, Map<String, String> resultBundleMapping) {
			super(getClosureCompilerArgs(ctx, bundles, resultBundleMapping));
			this.ctx = ctx;
			this.resultBundleMapping = resultBundleMapping;
		}

		/* (non-Javadoc)
		 * @see com.google.javascript.jscomp.JawrAbstractCommandLineRunner#checkModuleName(java.lang.String, java.util.Map)
		 */
		@Override
		protected void checkModuleName(String name) throws FlagUsageException{
			
		}
		    
		
		/**
		 * Creates inputs from a list of files.
		 * 
		 * @param files
		 *            A list of filenames
		 * @param allowStdIn
		 *            Whether '-' is allowed appear as a filename to represent
		 *            stdin. If true, '-' is only allowed to appear once.
		 * @return An array of inputs
		 * @throws
		 */
		@Override
		protected List<JSSourceFile> createInputs(List<String> files,
				boolean allowStdIn) throws IOException {
			
			List<JSSourceFile> inputs = new ArrayList<JSSourceFile>(
					files.size());

			ResourceBundlesHandler resourceBundlesHandler = getRsBundlesHandler(ctx);

			for (String filename : files) {
				if(filename.equals(JAWR_ROOT_MODULE_JS)){
					JSSourceFile newFile = JSSourceFile.fromCode(filename,
							"");
					inputs.add(newFile);
				}else if (!"-".equals(filename)) {
					Reader rd = null;
					StringWriter swr = new StringWriter();
					try{
						try {
							
							resourceBundlesHandler.writeBundleTo(PathNormalizer.concatWebPath(FAKE_PREFIX, filename), swr);
							rd = new StringReader(swr.getBuffer().toString());
						} catch (ResourceNotFoundException e) {
							// Do nothing
						}
						
						if(rd == null){
							try {
								rd = ctx.getRsReaderHandler().getResource(filename);
							} catch (ResourceNotFoundException e1) {
								throw new BundlingProcessException(e1);
							}
						}
						
						String jsCode = CharStreams.toString(rd);
						JSSourceFile newFile = JSSourceFile.fromCode(filename,
								jsCode);
						inputs.add(newFile);
					}finally{
						IOUtils.close(rd);
					}
				}
			}
			return inputs;
		}

		/**
		 * Converts a file name into a Writer. Returns null if the file name is
		 * null.
		 * @throws IOException 
		 */
		@Override
		protected OutputStream filenameToOutputStream(String fileName) throws IOException {
			
			if (fileName == null) {
				return null;
			}

			int fileExtensionIdx = fileName.lastIndexOf(".");
			String bundleName = fileName.substring(0, fileExtensionIdx).substring(2);
			
			String bundlePath = resultBundleMapping.get(bundleName);
			File outFile = new File(destDir, bundlePath);
			outFile.getParentFile().mkdirs();
			return new FileOutputStream(outFile);
		}

		/* (non-Javadoc)
		 * @see com.google.javascript.jscomp.JawrAbstractCommandLineRunner#doRun()
		 */
		public int doRun() throws FlagUsageException, IOException {
			int result = super.doRun();
			// Delete JAWR_ROOT_MODULE file
			File jawrRootModuleFile = new File(destDir, resultBundleMapping.get(JAWR_ROOT_MODULE_NAME));
			if(!jawrRootModuleFile.delete()){
				LOGGER.warn("Enable to delete JAWR_ROOT_MODULE.js file");
			}
			return result;
		}
	}
}
